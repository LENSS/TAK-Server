{"ast":null,"code":"import _classCallCheck from \"/home/radu/Server/src/takserver-tool-ui/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/radu/Server/src/takserver-tool-ui/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { GRID_CHECKBOX_SELECTION_COL_DEF } from '../../../../colDef';\nimport { buildWarning } from '../../../../utils/warning';\nfunction sanitizeCellValue(value, delimiterCharacter) {\n  if (typeof value === 'string') {\n    // Make sure value containing delimiter or line break won't be split into multiple rows\n    if ([delimiterCharacter, '\\n', '\\r', '\"'].some(function (delimiter) {\n      return value.includes(delimiter);\n    })) {\n      return \"\\\"\".concat(value.replace(/\"/g, '\"\"'), \"\\\"\");\n    }\n    return value;\n  }\n  return value;\n}\nexport var serializeCellValue = function serializeCellValue(cellParams, options) {\n  var delimiterCharacter = options.delimiterCharacter,\n    ignoreValueFormatter = options.ignoreValueFormatter;\n  var value;\n  if (ignoreValueFormatter) {\n    var _cellParams$value2;\n    var columnType = cellParams.colDef.type;\n    if (columnType === 'number') {\n      value = String(cellParams.value);\n    } else if (columnType === 'date' || columnType === 'dateTime') {\n      var _cellParams$value;\n      value = (_cellParams$value = cellParams.value) == null ? void 0 : _cellParams$value.toISOString();\n    } else if (typeof ((_cellParams$value2 = cellParams.value) == null ? void 0 : _cellParams$value2.toString) === 'function') {\n      value = cellParams.value.toString();\n    } else {\n      value = cellParams.value;\n    }\n  } else {\n    value = cellParams.formattedValue;\n  }\n  return sanitizeCellValue(value, delimiterCharacter);\n};\nvar objectFormattedValueWarning = buildWarning(['MUI: When the value of a field is an object or a `renderCell` is provided, the CSV export might not display the value correctly.', 'You can provide a `valueFormatter` with a string representation to be used.']);\nvar CSVRow = /*#__PURE__*/function () {\n  function CSVRow(options) {\n    _classCallCheck(this, CSVRow);\n    this.options = void 0;\n    this.rowString = '';\n    this.isEmpty = true;\n    this.options = options;\n  }\n  _createClass(CSVRow, [{\n    key: \"addValue\",\n    value: function addValue(value) {\n      if (!this.isEmpty) {\n        this.rowString += this.options.delimiterCharacter;\n      }\n      if (value === null || value === undefined) {\n        this.rowString += '';\n      } else if (typeof this.options.sanitizeCellValue === 'function') {\n        this.rowString += this.options.sanitizeCellValue(value, this.options.delimiterCharacter);\n      } else {\n        this.rowString += value;\n      }\n      this.isEmpty = false;\n    }\n  }, {\n    key: \"getRowString\",\n    value: function getRowString() {\n      return this.rowString;\n    }\n  }]);\n  return CSVRow;\n}();\nvar serializeRow = function serializeRow(_ref) {\n  var id = _ref.id,\n    columns = _ref.columns,\n    getCellParams = _ref.getCellParams,\n    delimiterCharacter = _ref.delimiterCharacter,\n    ignoreValueFormatter = _ref.ignoreValueFormatter;\n  var row = new CSVRow({\n    delimiterCharacter: delimiterCharacter\n  });\n  columns.forEach(function (column) {\n    var cellParams = getCellParams(id, column.field);\n    if (process.env.NODE_ENV !== 'production') {\n      if (String(cellParams.formattedValue) === '[object Object]') {\n        objectFormattedValueWarning();\n      }\n    }\n    row.addValue(serializeCellValue(cellParams, {\n      delimiterCharacter: delimiterCharacter,\n      ignoreValueFormatter: ignoreValueFormatter\n    }));\n  });\n  return row.getRowString();\n};\nexport function buildCSV(options) {\n  var columns = options.columns,\n    rowIds = options.rowIds,\n    delimiterCharacter = options.delimiterCharacter,\n    includeHeaders = options.includeHeaders,\n    includeColumnGroupsHeaders = options.includeColumnGroupsHeaders,\n    ignoreValueFormatter = options.ignoreValueFormatter,\n    apiRef = options.apiRef;\n  var CSVBody = rowIds.reduce(function (acc, id) {\n    return \"\".concat(acc).concat(serializeRow({\n      id: id,\n      columns: columns,\n      getCellParams: apiRef.current.getCellParams,\n      delimiterCharacter: delimiterCharacter,\n      ignoreValueFormatter: ignoreValueFormatter\n    }), \"\\r\\n\");\n  }, '').trim();\n  if (!includeHeaders) {\n    return CSVBody;\n  }\n  var filteredColumns = columns.filter(function (column) {\n    return column.field !== GRID_CHECKBOX_SELECTION_COL_DEF.field;\n  });\n  var headerRows = [];\n  if (includeColumnGroupsHeaders) {\n    var columnGroupLookup = apiRef.current.unstable_getAllGroupDetails();\n    var maxColumnGroupsDepth = 0;\n    var columnGroupPathsLookup = filteredColumns.reduce(function (acc, column) {\n      var columnGroupPath = apiRef.current.unstable_getColumnGroupPath(column.field);\n      acc[column.field] = columnGroupPath;\n      maxColumnGroupsDepth = Math.max(maxColumnGroupsDepth, columnGroupPath.length);\n      return acc;\n    }, {});\n    var _loop = function _loop(i) {\n      var headerGroupRow = new CSVRow({\n        delimiterCharacter: delimiterCharacter,\n        sanitizeCellValue: sanitizeCellValue\n      });\n      headerRows.push(headerGroupRow);\n      filteredColumns.forEach(function (column) {\n        var columnGroupId = (columnGroupPathsLookup[column.field] || [])[i];\n        var columnGroup = columnGroupLookup[columnGroupId];\n        headerGroupRow.addValue(columnGroup ? columnGroup.headerName || columnGroup.groupId : '');\n      });\n    };\n    for (var i = 0; i < maxColumnGroupsDepth; i += 1) {\n      _loop(i);\n    }\n  }\n  var mainHeaderRow = new CSVRow({\n    delimiterCharacter: delimiterCharacter,\n    sanitizeCellValue: sanitizeCellValue\n  });\n  filteredColumns.forEach(function (column) {\n    mainHeaderRow.addValue(column.headerName || column.field);\n  });\n  headerRows.push(mainHeaderRow);\n  var CSVHead = \"\".concat(headerRows.map(function (row) {\n    return row.getRowString();\n  }).join('\\r\\n'), \"\\r\\n\");\n  return \"\".concat(CSVHead).concat(CSVBody).trim();\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}