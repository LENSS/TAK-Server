{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { GridLogicOperator } from '../../../models';\nimport { GLOBAL_API_REF, isInternalFilter } from '../../../colDef/utils';\nimport { getDefaultGridFilterModel } from './gridFilterState';\nimport { buildWarning } from '../../../utils/warning';\nimport { gridColumnFieldsSelector, gridColumnLookupSelector, gridVisibleColumnFieldsSelector } from '../columns';\nvar hasEval;\ntry {\n  // eslint-disable-next-line no-eval\n  hasEval = eval('true');\n} catch (_) {\n  hasEval = false;\n}\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operator.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\nexport var cleanFilterItem = function cleanFilterItem(item, apiRef) {\n  var cleanItem = _extends({}, item);\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n  if (cleanItem.operator == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    var column = gridColumnLookupSelector(apiRef)[cleanItem.field];\n    cleanItem.operator = column && column.filterOperators[0].value;\n  }\n  return cleanItem;\n};\nvar filterModelDisableMultiColumnsFilteringWarning = buildWarning(['MUI: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the `DataGrid`, this prop is always `true`.'], 'error');\nvar filterModelMissingItemIdWarning = buildWarning('MUI: The `id` field is required on `filterModel.items` when you use multiple filters.', 'error');\nvar filterModelMissingItemOperatorWarning = buildWarning('MUI: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.', 'error');\nexport var sanitizeFilterModel = function sanitizeFilterModel(model, disableMultipleColumnsFiltering, apiRef) {\n  var hasSeveralItems = model.items.length > 1;\n  var items;\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    filterModelDisableMultiColumnsFilteringWarning();\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n  var hasItemsWithoutIds = hasSeveralItems && items.some(function (item) {\n    return item.id == null;\n  });\n  var hasItemWithoutOperator = items.some(function (item) {\n    return item.operator == null;\n  });\n  if (hasItemsWithoutIds) {\n    filterModelMissingItemIdWarning();\n  }\n  if (hasItemWithoutOperator) {\n    filterModelMissingItemOperatorWarning();\n  }\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return _extends({}, model, {\n      items: items.map(function (item) {\n        return cleanFilterItem(item, apiRef);\n      })\n    });\n  }\n  if (model.items !== items) {\n    return _extends({}, model, {\n      items: items\n    });\n  }\n  return model;\n};\nexport var mergeStateWithFilterModel = function mergeStateWithFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef) {\n  return function (filteringState) {\n    return _extends({}, filteringState, {\n      filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n    });\n  };\n};\nvar getFilterCallbackFromItem = function getFilterCallbackFromItem(filterItem, apiRef) {\n  if (!filterItem.field || !filterItem.operator) {\n    return null;\n  }\n  var column = apiRef.current.getColumn(filterItem.field);\n  if (!column) {\n    return null;\n  }\n  var parsedValue;\n  if (column.valueParser) {\n    var _filterItem$value;\n    var parser = column.valueParser;\n    parsedValue = Array.isArray(filterItem.value) ? (_filterItem$value = filterItem.value) == null ? void 0 : _filterItem$value.map(function (x) {\n      return parser(x);\n    }) : parser(filterItem.value);\n  } else {\n    parsedValue = filterItem.value;\n  }\n  var newFilterItem = _extends({}, filterItem, {\n    value: parsedValue\n  });\n  var filterOperators = column.filterOperators;\n  if (!(filterOperators != null && filterOperators.length)) {\n    throw new Error(\"MUI: No filter operators found for column '\".concat(column.field, \"'.\"));\n  }\n  var filterOperator = filterOperators.find(function (operator) {\n    return operator.value === newFilterItem.operator;\n  });\n  if (!filterOperator) {\n    throw new Error(\"MUI: No filter operator found for column '\".concat(column.field, \"' and operator value '\").concat(newFilterItem.operator, \"'.\"));\n  }\n  var hasUserFunctionLegacy = !isInternalFilter(filterOperator.getApplyFilterFn);\n  var hasUserFunctionV7 = !isInternalFilter(filterOperator.getApplyFilterFnV7);\n  if (filterOperator.getApplyFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {\n    var _applyFilterOnRow = filterOperator.getApplyFilterFnV7(newFilterItem, column);\n    if (typeof _applyFilterOnRow !== 'function') {\n      return null;\n    }\n    return {\n      v7: true,\n      item: newFilterItem,\n      fn: function fn(row) {\n        var value = apiRef.current.getRowValue(row, column);\n        return _applyFilterOnRow(value, row, column, apiRef);\n      }\n    };\n  }\n  var applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n  if (typeof applyFilterOnRow !== 'function') {\n    return null;\n  }\n  return {\n    v7: false,\n    item: newFilterItem,\n    fn: function fn(rowId) {\n      var params = apiRef.current.getCellParams(rowId, newFilterItem.field);\n      GLOBAL_API_REF.current = apiRef;\n      var result = applyFilterOnRow(params);\n      GLOBAL_API_REF.current = null;\n      return result;\n    }\n  };\n};\nvar filterItemsApplierId = 1;\n\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridRowIdGetter | undefined} getRowId The getter for row's id.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nexport var buildAggregatedFilterItemsApplier = function buildAggregatedFilterItemsApplier(getRowId, filterModel, apiRef, disableEval) {\n  var items = filterModel.items;\n  var appliers = items.map(function (item) {\n    return getFilterCallbackFromItem(item, apiRef);\n  }).filter(function (callback) {\n    return !!callback;\n  });\n  if (appliers.length === 0) {\n    return null;\n  }\n  if (!hasEval || disableEval) {\n    // This is the original logic, which is used if `eval()` is not supported (aka prevented by CSP).\n    return function (row, shouldApplyFilter) {\n      var resultPerItemId = {};\n      for (var i = 0; i < appliers.length; i += 1) {\n        var applier = appliers[i];\n        if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {\n          resultPerItemId[applier.item.id] = applier.v7 ? applier.fn(row) : applier.fn(getRowId ? getRowId(row) : row.id);\n        }\n      }\n      return resultPerItemId;\n    };\n  }\n\n  // We generate a new function with `eval()` to avoid expensive patterns for JS engines\n  // such as a dynamic object assignment, e.g. `{ [dynamicKey]: value }`.\n  var filterItemTemplate = \"(function filterItem$$(row, shouldApplyFilter) {\\n      \".concat(appliers.map(function (applier, i) {\n    return \"const shouldApply\".concat(i, \" = !shouldApplyFilter || shouldApplyFilter(\").concat(JSON.stringify(applier.item.field), \");\");\n  }).join('\\n'), \"\\n\\n      const result$$ = {\\n      \").concat(appliers.map(function (applier, i) {\n    return \"\".concat(JSON.stringify(String(applier.item.id)), \":\\n          !shouldApply\").concat(i, \" ?\\n            false :\\n            \").concat(applier.v7 ? \"appliers[\".concat(i, \"].fn(row)\") : \"appliers[\".concat(i, \"].fn(\").concat(getRowId ? 'getRowId(row)' : 'row.id', \")\"), \",\\n      \");\n  }).join('\\n'), \"};\\n\\n      return result$$;\\n    })\");\n\n  // eslint-disable-next-line no-eval\n  var filterItem = eval(filterItemTemplate.replaceAll('$$', String(filterItemsApplierId)));\n  filterItemsApplierId += 1;\n  return filterItem;\n};\n\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {GridRowIdGetter | undefined} getRowId The getter for row's id.\n * @param {any[]} filterModel The model with which we want to filter the rows.\n * @param {React.MutableRefObject<GridApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nexport var buildAggregatedQuickFilterApplier = function buildAggregatedQuickFilterApplier(getRowId, filterModel, apiRef) {\n  var _filterModel$quickFil, _filterModel$quickFil2, _filterModel$quickFil3;\n  var quickFilterValues = (_filterModel$quickFil = (_filterModel$quickFil2 = filterModel.quickFilterValues) == null ? void 0 : _filterModel$quickFil2.filter(Boolean)) != null ? _filterModel$quickFil : [];\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n  var quickFilterExcludeHiddenColumns = (_filterModel$quickFil3 = filterModel.quickFilterExcludeHiddenColumns) != null ? _filterModel$quickFil3 : false;\n  var columnFields = quickFilterExcludeHiddenColumns ? gridVisibleColumnFieldsSelector(apiRef) : gridColumnFieldsSelector(apiRef);\n  var appliersPerField = [];\n  columnFields.forEach(function (field) {\n    var column = apiRef.current.getColumn(field);\n    var getApplyQuickFilterFn = column == null ? void 0 : column.getApplyQuickFilterFn;\n    var getApplyQuickFilterFnV7 = column == null ? void 0 : column.getApplyQuickFilterFnV7;\n    var hasUserFunctionLegacy = !isInternalFilter(getApplyQuickFilterFn);\n    var hasUserFunctionV7 = !isInternalFilter(getApplyQuickFilterFnV7);\n    if (getApplyQuickFilterFnV7 && !(hasUserFunctionLegacy && !hasUserFunctionV7)) {\n      appliersPerField.push({\n        column: column,\n        appliers: quickFilterValues.map(function (value) {\n          return {\n            v7: true,\n            fn: getApplyQuickFilterFnV7(value, column, apiRef)\n          };\n        })\n      });\n    } else if (getApplyQuickFilterFn) {\n      appliersPerField.push({\n        column: column,\n        appliers: quickFilterValues.map(function (value) {\n          return {\n            v7: false,\n            fn: getApplyQuickFilterFn(value, column, apiRef)\n          };\n        })\n      });\n    }\n  });\n  return function isRowMatchingQuickFilter(row, shouldApplyFilter) {\n    var result = {};\n    var usedCellParams = {};\n\n    /* eslint-disable no-restricted-syntax, no-labels, no-continue */\n    outer: for (var v = 0; v < quickFilterValues.length; v += 1) {\n      var filterValue = quickFilterValues[v];\n      for (var i = 0; i < appliersPerField.length; i += 1) {\n        var _appliersPerField$i = appliersPerField[i],\n          column = _appliersPerField$i.column,\n          appliers = _appliersPerField$i.appliers;\n        var field = column.field;\n        if (shouldApplyFilter && !shouldApplyFilter(field)) {\n          continue;\n        }\n        var applier = appliers[v];\n        var value = apiRef.current.getRowValue(row, column);\n        if (applier.fn === null) {\n          continue;\n        }\n        if (applier.v7) {\n          var isMatching = applier.fn(value, row, column, apiRef);\n          if (isMatching) {\n            result[filterValue] = true;\n            continue outer;\n          }\n        } else {\n          var _usedCellParams$field;\n          var cellParams = (_usedCellParams$field = usedCellParams[field]) != null ? _usedCellParams$field : apiRef.current.getCellParams(getRowId ? getRowId(row) : row.id, field);\n          usedCellParams[field] = cellParams;\n          var _isMatching = applier.fn(cellParams);\n          if (_isMatching) {\n            result[filterValue] = true;\n            continue outer;\n          }\n        }\n      }\n      result[filterValue] = false;\n    }\n    /* eslint-enable no-restricted-syntax, no-labels, no-continue */\n\n    return result;\n  };\n};\nexport var buildAggregatedFilterApplier = function buildAggregatedFilterApplier(getRowId, filterModel, apiRef, disableEval) {\n  var isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(getRowId, filterModel, apiRef, disableEval);\n  var isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(getRowId, filterModel, apiRef);\n  return function isRowMatchingFilters(row, shouldApplyFilter, result) {\n    var _isRowMatchingFilterI, _isRowMatchingQuickFi;\n    result.passingFilterItems = (_isRowMatchingFilterI = isRowMatchingFilterItems == null ? void 0 : isRowMatchingFilterItems(row, shouldApplyFilter)) != null ? _isRowMatchingFilterI : null;\n    result.passingQuickFilterValues = (_isRowMatchingQuickFi = isRowMatchingQuickFilter == null ? void 0 : isRowMatchingQuickFilter(row, shouldApplyFilter)) != null ? _isRowMatchingQuickFi : null;\n  };\n};\nvar isNotNull = function isNotNull(result) {\n  return result != null;\n};\nvar filterModelItems = function filterModelItems(cache, apiRef, items) {\n  if (!cache.cleanedFilterItems) {\n    cache.cleanedFilterItems = items.filter(function (item) {\n      return getFilterCallbackFromItem(item, apiRef) !== null;\n    });\n  }\n  return cache.cleanedFilterItems;\n};\nexport var passFilterLogic = function passFilterLogic(allFilterItemResults, allQuickFilterResults, filterModel, apiRef, cache) {\n  var cleanedFilterItems = filterModelItems(cache, apiRef, filterModel.items);\n  var cleanedFilterItemResults = allFilterItemResults.filter(isNotNull);\n  var cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull);\n\n  // get result for filter items model\n  if (cleanedFilterItemResults.length > 0) {\n    var _filterModel$logicOpe;\n    // Return true if the item pass with one of the rows\n    var filterItemPredicate = function filterItemPredicate(item) {\n      return cleanedFilterItemResults.some(function (filterItemResult) {\n        return filterItemResult[item.id];\n      });\n    };\n    var logicOperator = (_filterModel$logicOpe = filterModel.logicOperator) != null ? _filterModel$logicOpe : getDefaultGridFilterModel().logicOperator;\n    if (logicOperator === GridLogicOperator.And) {\n      var passesAllFilters = cleanedFilterItems.every(filterItemPredicate);\n      if (!passesAllFilters) {\n        return false;\n      }\n    } else {\n      var passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);\n      if (!passesSomeFilters) {\n        return false;\n      }\n    }\n  }\n\n  // get result for quick filter model\n  if (cleanedQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {\n    var _filterModel$quickFil4;\n    // Return true if the item pass with one of the rows\n    var quickFilterValuePredicate = function quickFilterValuePredicate(value) {\n      return cleanedQuickFilterResults.some(function (quickFilterValueResult) {\n        return quickFilterValueResult[value];\n      });\n    };\n    var quickFilterLogicOperator = (_filterModel$quickFil4 = filterModel.quickFilterLogicOperator) != null ? _filterModel$quickFil4 : getDefaultGridFilterModel().quickFilterLogicOperator;\n    if (quickFilterLogicOperator === GridLogicOperator.And) {\n      var passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);\n      if (!passesAllQuickFilterValues) {\n        return false;\n      }\n    } else {\n      var passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);\n      if (!passesSomeQuickFilterValues) {\n        return false;\n      }\n    }\n  }\n  return true;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}