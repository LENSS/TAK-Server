

package com.bbn.marti.util.concurrent.future;

import java.util.concurrent.Callable;
import java.util.concurrent.Executor;

import org.apache.log4j.Logger;
import org.slf4j.LoggerFactory;

import com.bbn.marti.util.Assertion;
import com.google.common.base.Optional;

/**
* An asynchronous future implementation that encapsulates a runnable/runnable with result/callable task, and
* manages mediation of job/callback adding. When run (this object implements the Runnable interface), the run
* method calls the enclosed task, and sets its result (success of type V, or a throwable generated by 
* an exception)
*
*/
public class AsyncFutureImpl<V> extends AbstractDirectExecutorAsyncFuture<V> implements Runnable {
	/**
	* An inner class for adapting a client AsynchronousCallback to a runnable that, when 
	* executed after the contained job, checks the
	* result of the outer class and forwards it to the encapsulated callback.
	*/
	protected class AsyncCallbackAdapter implements Runnable {
		private final AsyncCallback<V> callback;
		
		protected AsyncCallbackAdapter(AsyncCallback<V> callback) {
			this.callback = callback;
		}
		
		public void run() {
			Assertion.notNull(AsyncFutureImpl.this.outcomeStatus, "Status should have been set before being called");
			
			switch(AsyncFutureImpl.this.outcomeStatus) {
				case SUCCESS:
					Assertion.notNull(AsyncFutureImpl.this.successResult, "SuccessResult should have been set on successful completion");
					callback.onSuccess(AsyncFutureImpl.this.getResult());
					break;
				case EXCEPT:
					Assertion.notNull(AsyncFutureImpl.this.failureResult, "failureResult should have been set on exceptional completion");
					callback.onFailure(AsyncFutureImpl.this.getException());
					break;
				default:
					Assertion.fail();
					break;
			}
		}
	}

    /**
    * A static, singly-linked node class
    * for enqueueing job/executor pairs
    * to the tail end of the future
    *
    * This avoids the bulk of an third-party
    * list/concurrent structure/container
    *
    * The job may be null, which indicates the tail
    * (in practice, we don't execute it)
    */
	protected static class ListenerNode {
		
		protected ListenerNode next = null;
		protected final Runnable job;
		protected final Executor executor;
		
		public ListenerNode(Runnable job, Executor executor) {
			
			this.job = job;
			this.executor = executor;
		}
	}
	
	private final static Logger log = Logger.getLogger(AsyncFutureImpl.class);
	protected volatile Callable<V> job; // job to execute for this async future
	protected ListenerNode receiverHead; // protected by synchronized
	
	protected volatile Outcome outcomeStatus; 	   // state of the future, set after the contained job is finished
	protected volatile Optional<V> successResult; // encapsulation of the computation result -- null here is reserved for internal usage,
	protected volatile Exception failureResult;  // throwable generated by execution of the contained job

	/**
	* Wrap the job in a callable that returns the given result
	* upon completion.
	*/
	protected AsyncFutureImpl(final Runnable job, final V result) {
		this(new Callable<V>() {
			public V call() {
				job.run();
				return result;
			}
		});
	}
	
	protected AsyncFutureImpl(Callable<V> callable) {
		this();

        // store callable
		this.job = callable;
	}

	protected AsyncFutureImpl() {
		this.receiverHead = new ListenerNode(null, null);

		this.outcomeStatus = Outcome.SCHEDULED;
		this.successResult = null;
		this.failureResult = null;
	}
	
	public static <V> AsyncFutureImpl<V> create(Callable<V> callable) {
		return new AsyncFutureImpl<V>(callable);
	}
	
	public static <V> AsyncFutureImpl<V> create(Runnable job, V result) {
		return new AsyncFutureImpl<V>(job, result);
	}
	
	public static AsyncFutureImpl<?> create(Runnable job) {
		return create(job, (Object) null);
	}
	
	/**
	* Execution method for (safely) running the contained job,
	* setting the state of this future based on its success/except outcome,
	* and notifying all registered receivers/changing the state of the future
	* so that all future adders 
	*/
    @Override
	public void run() {
		Assertion.notNull(job, "Job should be nonnull before this runs");
        
        // set state to in progress -- rough signal
		this.outcomeStatus = Outcome.EXECUTING;
		
        // actually does the execution portion
        doExecute();
		
		// void out head pointer
		ListenerNode oldHead = getHeadAndVoid();
		
		// call linked jobs
		notifyReceivers(oldHead);
	}
    
    private void doExecute() {
        try {
            V result = job.call();
            setResult(result);
        } catch (Exception thrown) {
            log.debug("AsyncFuture encountered exception executing delegate job", thrown);
            setException(thrown);
        } finally {
            // void out job pointer to prevent anyone else from running it
            // not quite thread safe, but good enough for debugging (we should never
            // execute a task twice) and the notify call will catch races anyway
            job = null;
        }
    }
	
	/**
	* Methods for getting the status/result/exception values. All assert that the targets
	* are nonnull (ie, the method is being called at the right time, and the right method is
	* being called)
	*/
    @Override
	public Outcome getStatus() {
		return this.outcomeStatus;
	}

    @Override
	public Exception getException() {
		Assertion.notNull(this.failureResult, "This should never be called unless the result has been set");
		return this.failureResult;
	}

    @Override
	public V getResult() {
		Assertion.notNull(this.successResult, "This should never be called unless the result has been set");
		return this.successResult.orNull();
	}
	
	protected boolean done() {
		return (receiverHead == null || getHead() == null);
	}
	
	protected void notifyReceivers(ListenerNode src) {
		Assertion.notNull(src, "Trying to notify already cleared list of receivers");

        // reverse listener list, preserving ordering (this may seem odd, but the nodes have low overhead compared to heavier lists, and we only ever expect a handful of listeners)
		ListenerNode dest = null;
		while (src != null) {
			ListenerNode tmp = src;
			src = src.next;
			tmp.next = dest;
			dest = tmp;
		}

		// DEBUG
		Assertion.notNull(dest, "Should never be null");
		
		while (dest != null) {
			Runnable job = dest.job;

			if (job != null) {
				Executor executor = (dest.executor != null) ? dest.executor : AsyncFutures.directSmotheringExecutor();
				executor.execute(job);
			}
			
			dest = dest.next;
		}
	}
	
	protected boolean setResult(V result) {
		Assertion.isNull(this.successResult);

		this.outcomeStatus = Outcome.SUCCESS;
		this.successResult = Optional.fromNullable(result);

		return true;
	}
	
	protected boolean setException(Exception thrown) {
		Assertion.isNull(this.successResult);
		
		this.outcomeStatus = Outcome.EXCEPT;
		this.failureResult = thrown;
		
		return true;
	}
	
	protected synchronized ListenerNode getHeadAndVoid() {
		ListenerNode head = this.receiverHead;
		this.receiverHead = null;
		
		return head;
	}

	private synchronized ListenerNode getHead() {
		return this.receiverHead;
	}
	
	private synchronized boolean prependNode(ListenerNode node) {
		if (this.receiverHead != null) {
			node.next = this.receiverHead;
			this.receiverHead = node;
			return true;
		} else {
			return false;
		}
	}
	
	/**
	* Double-checked append job method. If the job 
	*/
    @Override
	public final void addJob(Runnable runnable, Executor executor) {
		Assertion.areNotNull(runnable, executor);
		
		if (this.receiverHead == null || !prependNode(new ListenerNode(runnable, executor))) {
			executor.execute(runnable);
		}
	}
	
    @Override
	public final void addCallback(AsyncCallback<V> callback, Executor executor) {
		addJob(new AsyncCallbackAdapter(callback), executor);
	}
}